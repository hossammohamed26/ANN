# -*- coding: utf-8 -*-
"""ANN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15K7CXqi7SQo795QbqfG89aGLzMaMqGQ8
"""

import numpy as np
import pandas as pd
import random as rd

def readFile(Filename):
    nNodes = pd.read_csv(Filename, header=None, delim_whitespace=True, nrows=2)
    dataset = pd.read_csv(Filename, skiprows=[0, 1], header=None, delim_whitespace=True)
    m, l, n, k = int(nNodes[0][0]), int(nNodes[1][0]), int(nNodes[2][0]), int(nNodes[0][1])
    x = dataset.iloc[:,:m]
    y = dataset.iloc[:,m:]
    return m, l, n, k, x, y

def normalization(x_data):
    x_data = (x_data - x_data.mean()) / x_data.std()
    return x_data

def randomWeights(col, row, n):
    w = [[0] * col] * row
    nW=1 / ((col * row) + ( row * n))
    for i in range(row):
      for j in range(col):
        w[i][j]=rd.uniform(-nW,nW)
    return w

def sigmoid(z):  
    return 1 / (1 + (np.exp(-z)))

def feedForward(wH, wO, hidden, output, x):
        hiddenOutput = []
        out = []
        for i in range(hidden):
            total=0
            for j in range(len(x)):
              total+= x[j] * wH[i][j]
              #print(x[j], wH[i][j])
            hiddenOutput.append(sigmoid(total))
            #print('Total= ', sigmoid(total))

        for i in range(output):
          total=0
          for j in range(len(hiddenOutput)):
              total+= hiddenOutput[j] * wO[i][j]
              #print(hiddenOutput[j], wO[i][j])
          out.append(sigmoid(total))
          #print('Total= ', sigmoid(total))

        return hiddenOutput, out

def backProbagation(hiddenout, out, y, wH, wO,):
    deltaOutput = []
    deltaHidden = []
    total=0
    for i in range(len(out)):
      deltaOutput.append( (out[i] - y[i]) * (out[i] * (1 - out[i])) )

    for i in range(len(hiddenout)):
      sumDeltas=0
      for j in range(len(deltaOutput)):
        sumDeltas += deltaOutput[j] * wO[j][i]
      deltaHidden.append(sumDeltas * hiddenout[i] * (1 - hiddenout[i]))
    return deltaOutput, deltaHidden

def updataWeights(alpha, wO, wH, x, deltaOutput, deltaHidden, hiddenout, out):
    for i in range(len(deltaOutput)):
      for j in range(len(deltaHidden)):
          wO[i][j] = wO[i][j] - (alpha * deltaOutput[i] * hiddenout[j])
          #print(wO[i][j], alpha, deltaOutput[i], hiddenout[j])

    for i in range(len(deltaHidden)):
      for j in range(len(x)):
          wH[i][j] = wH[i][j] - (alpha * (deltaHidden[i]) * x[j])
          #print(wH[i][j], alpha, deltaHidden[i], x[j])
    return wO, wH

def MSE(predOut, y):
    mse=0
    for i in range(len(y)):
      mse += ((y[i] - predOut[i]) ** 2 ) * (1.0/2)
    return mse

input, hidden, output, training, x, y = readFile("train.txt")
x = normalization(x)
#y = normalization(y)
x = np.array(x)
y = np.array(y)
#print(input, hidden, output, training, x, y)

wH = np.array(randomWeights(input, hidden, output))
wO = np.array(randomWeights(hidden, output, input))
#print(wH)
#print(wO)

#wH = np.array([[.5,-.8],[0.3,0.9]])
#wO = np.array([[1.1,-.9],[.8,-1.0]])
#x = np.array([1,3])
#hiddenout, out = feedForward(wH,wO,2,2,x)
#print(hiddenout, out)
#MSE(out, [0])

#deltaOutput, deltaHidden = backProbagation(hiddenout, out, [.9,.1], wH, wO)
#print(deltaOutput, deltaHidden)

#wO, wH =updataWeights(.5, wO,wH,x,deltaOutput, deltaHidden, hiddenout, out)
#print(wO, wH)

#hiddenout, out = feedForward(wH,wO,2,2,x)
#print(hiddenout, out)

def neuralNetwrok(input, hidden, output, training, x, y, wO, wH, alpha, iterations):
    newY = []
    for i in range(iterations):
      newY = []
      for j in range(training):
        hiddenout, out = feedForward(wH,wO,hidden,output,x[j])
        deltaOutput, deltaHidden = backProbagation(hiddenout, out, y[j], wH, wO)
        wO, wH = updataWeights(alpha, wO, wH, x[j], deltaOutput, deltaHidden, hiddenout, out)
        newY.append(out)
    print("MSE = ", MSE(newY, y)/training)

neuralNetwrok(input, hidden, output, training, x, y, wO, wH, .5, 500)